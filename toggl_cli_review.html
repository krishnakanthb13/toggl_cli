<!--
File: toggl_cli_review.html
Description: Front-end application for reviewing Toggl CLI entries with AI-generated summaries.
Parameters: None (client-side application).
Inputs: Loads `toggl_cli_logs.txt` from server or local storage, parses timestamped entries.
Processing: Parses entries, groups by date/year/month, displays overview, allows AI summary generation via Google Gemini API, and saves AI logs.
Outputs: Renders interactive UI with entry lists, date navigation, AI summary display, and downloadable AI log.
-->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toggl Report Viewer</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⏱️</text></svg>">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React and ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Marked for Markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- DOMPurify for XSS protection -->
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>

    <style>
        body {
            background-color: #111827;
            /* gray-900 */
            color: #f3f4f6;
            /* gray-100 */
        }

        .prose-invert h1,
        .prose-invert h2,
        .prose-invert h3,
        .prose-invert h4 {
            color: #f3f4f6;
        }

        .prose-invert strong {
            color: #fff;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        // Main application script for Toggl Reviewer
        // Lucide Icons wrapper - optimized to run createIcons only once per icon update
        const Icon = ({ name, className }) => {
            const iconRef = React.useRef(null);
            React.useEffect(() => {
                if (iconRef.current) {
                    lucide.createIcons({ nodes: [iconRef.current] });
                }
            }, [name]);
            return <i ref={iconRef} data-lucide={name} className={className}></i>;
        };

        const Clock = ({ className }) => <Icon name="clock" className={className} />;
        const Calendar = ({ className }) => <Icon name="calendar" className={className} />;
        const ArrowLeft = ({ className }) => <Icon name="arrow-left" className={className} />;
        const Upload = ({ className }) => <Icon name="upload" className={className} />;
        const Sparkles = ({ className }) => <Icon name="sparkles" className={className} />;
        const Key = ({ className }) => <Icon name="key" className={className} />;
        const X = ({ className }) => <Icon name="x" className={className} />;

        const TimeTracker = () => {
            const [entries, setEntries] = React.useState([]);
            const [view, setView] = React.useState('loading');
            const [dates, setDates] = React.useState([]);
            const [groupedDates, setGroupedDates] = React.useState({});
            const [selectedDate, setSelectedDate] = React.useState(null);
            const [loadingError, setLoadingError] = React.useState(null);

            // Gemini State
            const [apiKey, setApiKey] = React.useState(localStorage.getItem('gemini_api_key') || '');
            const [showKeyInput, setShowKeyInput] = React.useState(false);
            const [isGenerating, setIsGenerating] = React.useState(false);
            const [summaries, setSummaries] = React.useState({}); // Changed from single summary to dictionary

            React.useEffect(() => {
                loadData();
            }, []);

            React.useEffect(() => {
                if (entries.length > 0) {
                    extractAndGroupDates();
                    // Determine initial view if not already set or invalid
                    if (view === 'loading' || view === 'upload') {
                        setView('overview');
                    }
                } else if (view !== 'loading') {
                    // If entries is empty but view is active, maybe go to upload?
                    // But we might be strictly clearing. Let's stick to upload if empty.
                    if (view !== 'upload') setView('upload');
                }
            }, [entries]);

            const saveApiKey = (key) => {
                setApiKey(key);
                localStorage.setItem('gemini_api_key', key);
                setShowKeyInput(false);
            };

            const loadData = async () => {
                // Load summaries from cache
                const cachedSummaries = localStorage.getItem('toggl_cli_summaries');
                if (cachedSummaries) {
                    try {
                        setSummaries(JSON.parse(cachedSummaries));
                    } catch (e) {
                        console.error("Failed to parse cached summaries", e);
                    }
                }

                // Try LocalStorage first
                const cachedData = localStorage.getItem('toggl_cli_data');
                if (cachedData) {
                    console.log("Loaded from cache");
                    parseFileContent(cachedData);
                    // We don't return here, we can try to refresh from server in background if we wanted,
                    // but for this simple app, cache first is good.
                    // If file fetch fails, we at least have cache.
                }

                try {
                    const response = await fetch('toggl_cli_logs.txt');
                    if (response.ok) {
                        const text = await response.text();
                        // Update cache if different? Or just always update.
                        if (text !== cachedData) {
                            console.log("New data found, updating...");
                            localStorage.setItem('toggl_cli_data', text);
                            parseFileContent(text);
                        }
                    } else {
                        if (!cachedData) throw new Error('File not found');
                    }
                } catch (error) {
                    console.log('Auto-load failed', error);
                    if (!cachedData) {
                        setLoadingError('Could not load toggl_cli_logs.txt and no cache found.');
                        setView('upload');
                    }
                }
            };

            const extractAndGroupDates = () => {
                const uniqueDates = [...new Set(entries.map(entry => {
                    const date = new Date(entry.timestamp);
                    return date.toISOString().split('T')[0];
                }))].sort().reverse();

                setDates(uniqueDates);

                const grouped = {};
                uniqueDates.forEach(date => {
                    const dateObj = new Date(date);
                    const year = dateObj.getFullYear();
                    const month = dateObj.toLocaleString('en-US', { month: 'long' });

                    if (!grouped[year]) {
                        grouped[year] = {};
                    }
                    if (!grouped[year][month]) {
                        grouped[year][month] = [];
                    }
                    grouped[year][month].push(date);
                });

                setGroupedDates(grouped);
            };

            const parseEntry = (line) => {
                // Updated regex: colon after tag is now optional to handle entries like "(P) Disturbance!"
                const regex = /\[(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})\]\s*\(([^)]*)\):?\s*(.+)/;
                const match = line.match(regex);

                if (match) {
                    const [, datePart, timePart, tag, note] = match;
                    const timestamp = `${datePart}T${timePart}`;
                    return {
                        timestamp: new Date(timestamp).toISOString(),
                        tag: tag.trim(),
                        note: note.trim()
                    };
                }
                return null;
            };

            const parseFileContent = (text) => {
                const lines = text.split('\n').filter(line => line.trim());
                const parsedEntries = lines
                    .map(line => parseEntry(line))
                    .filter(entry => entry !== null);

                setEntries(parsedEntries);
            };

            const saveToAiLog = (dateStr, summaryText) => {
                const separator = "\n\n---\n\n";
                const newEntry = `Date: ${dateStr}\n\n${summaryText}${separator}`;

                // Get existing log or start empty
                let currentLog = localStorage.getItem('toggl_cli_ai_log') || "";

                // Avoid rewriting if it looks like the last entry is the same (simple check)
                if (!currentLog.includes(newEntry.trim())) {
                    currentLog += newEntry;
                    localStorage.setItem('toggl_cli_ai_log', currentLog);
                    // downloadAiLog(currentLog); // Auto-download removed
                } else {
                    // It exists, maybe just update the file anyway so user gets latest
                    // downloadAiLog(currentLog); // Auto-download removed
                }
            };

            const downloadAiLog = async (content) => {
                // Clean content: remove excessive newlines (3 or more becomes 2)
                const cleanContent = content.replace(/\n{3,}/g, '\n\n');

                // Try to use the modern File System Access API to pick location
                if (window.showSaveFilePicker) {
                    try {
                        const handle = await window.showSaveFilePicker({
                            suggestedName: 'toggl_cli_ai.txt',
                            types: [{
                                description: 'Text File',
                                accept: { 'text/plain': ['.txt'] },
                            }],
                        });
                        const writable = await handle.createWritable();
                        await writable.write(cleanContent);
                        await writable.close();
                        return; // Success
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error('File access error:', err);
                            alert('Could not save to chosen location. Falling back to default download.');
                        } else {
                            return; // User cancelled
                        }
                    }
                }

                // Fallback for browsers without File System Access API
                const blob = new Blob([cleanContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'toggl_cli_ai.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            // CONFIGURATION: Model and Prompt
            const AI_CONFIG = {
                model: "gemma-3-27b-it", // Updated to use the requested model
                // You can customize the system instruction equivalent here
                basePrompt: `Analyze these time tracking entries and provide a concise summary of the day.
Focus on:
1. Key achievements (Work/Tasks completions).
2. Flow and consistency (disturbances, breaks).
3. Overall mood/productivity based on the notes.
Use professional but encouraging tone and provide points.`,
            };

            const generateSummary = async (dateEntries, dateStr) => {
                if (!apiKey) {
                    setShowKeyInput(true);
                    return;
                }

                setIsGenerating(true);
                // setSummary(null); // Don't clear immediately, allows invalidation visual if needed, but for now just overwrite on success

                const entriesText = dateEntries.map(e =>
                    `[${formatTime(e.timestamp)}] (${e.tag}): ${e.note}`
                ).join('\n');

                // PROMPT CONSTRUCTION: This is where the context is assembled
                const prompt = `${AI_CONFIG.basePrompt}

                Date: ${dateStr}

                Entries:
                ${entriesText}`;

                console.log("Using Model:", AI_CONFIG.model);
                console.log("Sending Prompt:", prompt);

                try {
                    // Using the updated model in the API endpoint
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${AI_CONFIG.model}:generateContent?key=${apiKey}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [{ text: prompt }]
                            }]
                        })
                    });

                    const data = await response.json();

                    if (data.error) {
                        throw new Error(data.error.message);
                    }

                    // Check if candidates exists
                    if (!data.candidates || data.candidates.length === 0) {
                        throw new Error("No response generated. The model might not support this region or input.");
                    }

                    const text = data.candidates[0].content.parts[0].text;
                    // Update summaries state
                    const newSummaries = { ...summaries, [dateStr]: text };
                    setSummaries(newSummaries);
                    localStorage.setItem('toggl_cli_summaries', JSON.stringify(newSummaries));

                    // Append to AI Log
                    saveToAiLog(dateStr, text);

                } catch (error) {
                    alert('Failed to generate summary: ' + error.message);
                } finally {
                    setIsGenerating(false);
                }
            };

            const handleFileUpload = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                try {
                    const text = await file.text();
                    localStorage.setItem('toggl_cli_data', text); // Save to cache
                    parseFileContent(text);
                    setView('overview');
                } catch (error) {
                    console.error('Error reading file:', error);
                    alert('Error reading file. Please try again.');
                }
            };

            const formatTime = (timestamp) => {
                const date = new Date(timestamp);
                return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;
            };

            const formatDate = (dateStr) => {
                const date = new Date(dateStr);
                return date.toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            };

            const getEntriesForDate = (dateStr) => {
                return entries.filter(entry => {
                    const entryDate = new Date(entry.timestamp).toISOString().split('T')[0];
                    return entryDate === dateStr;
                });
            };

            const handleDateSelect = (dateStr) => {
                setSelectedDate(dateStr);
                // setSummary(null); // Removed: Do not clear summary on nav
                setView('details'); // Explicitly switch to details view
            };

            // render markdown with XSS protection via DOMPurify
            const Markdown = ({ content }) => {
                const sanitizedHtml = React.useMemo(() => {
                    const rawHtml = marked.parse(content || '');
                    return DOMPurify.sanitize(rawHtml);
                }, [content]);
                return (
                    <div className="prose prose-invert prose-sm max-w-none" dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />
                );
            };

            // Loading view
            if (view === 'loading') {
                return (
                    <div className="flex items-center justify-center min-h-screen text-gray-400">
                        <p>Loading entries...</p>
                    </div>
                );
            }

            // Upload view (no entries loaded)
            if (view === 'upload' && entries.length === 0) {
                return (
                    <div className="max-w-4xl mx-auto p-4 bg-gray-900 min-h-screen">
                        <div className="bg-gray-800 rounded-lg shadow-lg p-6 border border-gray-700">
                            <h1 className="text-2xl font-bold mb-4 text-gray-100 flex items-center justify-center">
                                <Clock className="w-7 h-7 mr-2" />
                                Toggl Report Viewer
                            </h1>

                            {loadingError && (
                                <div className="bg-red-900/50 border border-red-700 rounded-lg p-4 mb-4 text-red-200">
                                    <p>{loadingError}</p>
                                </div>
                            )}

                            <div className="text-center mt-8">
                                <Upload className="w-14 h-14 mx-auto mb-3 text-gray-500" />
                                <p className="text-gray-400 mb-4">Upload your toggl_cli_logs.txt file</p>

                                <label className="inline-block bg-blue-600 text-white py-2 px-5 rounded-lg hover:bg-blue-700 cursor-pointer font-medium">
                                    <input
                                        type="file"
                                        accept=".txt"
                                        onChange={handleFileUpload}
                                        className="hidden"
                                    />
                                    Choose File
                                </label>
                            </div>
                        </div>
                    </div>
                );
            }

            // Details view for selected date
            if (view === 'details' && selectedDate) {
                const dateEntries = getEntriesForDate(selectedDate);
                return (
                    <div className="max-w-4xl mx-auto p-2 bg-gray-900 min-h-screen">
                        <div className="bg-gray-800 rounded-lg shadow-lg p-3 border border-gray-700">
                            <div className="flex justify-between items-center mb-3">
                                <button
                                    onClick={() => {
                                        setSelectedDate(null);
                                        setView('overview'); // Go back to overview explicitly
                                    }}
                                    className="flex items-center text-blue-400 hover:text-blue-300 text-sm"
                                >
                                    <ArrowLeft className="w-4 h-4 mr-1" />
                                    Back to dates
                                </button>
                                <div className="flex gap-2">
                                    <button
                                        onClick={() => {
                                            if (confirm('Refresh data from server?')) {
                                                loadData();
                                            }
                                        }}
                                        className="text-gray-500 hover:text-gray-300 text-xs flex items-center"
                                        title="Reload Data"
                                    >
                                        <Clock className="w-3 h-3 mr-1" />
                                        Refresh
                                    </button>
                                    <button
                                        onClick={() => setShowKeyInput(true)}
                                        className="text-gray-500 hover:text-gray-300 text-xs flex items-center"
                                        title="Set API Key"
                                    >
                                        <Key className="w-3 h-3 mr-1" />
                                        {apiKey ? 'API Key Set' : 'Set Gemini Key'}
                                    </button>
                                    <button
                                        onClick={() => {
                                            const log = localStorage.getItem('toggl_cli_ai_log');
                                            if (log) downloadAiLog(log);
                                            else alert("No AI logs saved yet.");
                                        }}
                                        className="text-gray-500 hover:text-gray-300 text-xs flex items-center"
                                        title="Download AI Log"
                                    >
                                        <Upload className="w-3 h-3 mr-1" />
                                        Save AI Log
                                    </button>
                                </div>
                            </div>

                            <div className="flex justify-between items-end mb-4 border-b border-gray-700 pb-3">
                                <h2 className="text-lg font-bold text-gray-100 flex items-center">
                                    {formatDate(selectedDate)}
                                </h2>
                                <button
                                    onClick={() => generateSummary(dateEntries, formatDate(selectedDate))}
                                    disabled={isGenerating}
                                    className="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1.5 rounded text-sm flex items-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
                                >
                                    <Sparkles className="w-4 h-4 mr-1.5" />
                                    {isGenerating ? 'Analyzing...' : 'Generate AI Summary'}
                                </button>
                            </div>

                            {/* API Key Modal */}
                            {showKeyInput && (
                                <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50 p-4">
                                    <div className="bg-gray-800 border border-gray-600 p-4 rounded-lg w-full max-w-sm">
                                        <div className="flex justify-between items-center mb-3">
                                            <h3 className="font-bold text-gray-200">Set Gemini API Key</h3>
                                            <button onClick={() => setShowKeyInput(false)} className="text-gray-400 hover:text-white"><X className="w-4 h-4" /></button>
                                        </div>
                                        <p className="text-xs text-gray-400 mb-3">
                                            Enter your Google Gemini API Key to enable AI summaries. The key is stored locally in your browser.
                                        </p>
                                        <input
                                            type="password"
                                            placeholder="Paste API Key here..."
                                            className="w-full bg-gray-900 border border-gray-700 rounded p-2 text-white mb-3 text-sm focus:border-blue-500 focus:outline-none"
                                            defaultValue={apiKey}
                                            id="apiKeyInput"
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') saveApiKey(e.target.value);
                                            }}
                                        />
                                        <div className="flex justify-end gap-2">
                                            <button
                                                onClick={() => setShowKeyInput(false)}
                                                className="px-3 py-1.5 text-xs text-gray-300 hover:bg-gray-700 rounded"
                                            >
                                                Cancel
                                            </button>
                                            <button
                                                onClick={() => {
                                                    const input = document.getElementById('apiKeyInput');
                                                    if (input) saveApiKey(input.value);
                                                }}
                                                className="bg-blue-600 hover:bg-blue-500 text-white px-3 py-1.5 text-xs rounded"
                                            >
                                                Save Key
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Summary Section */}
                            {summaries[formatDate(selectedDate)] && (
                                <div className="mb-4 bg-purple-900/20 border border-purple-500/30 rounded-lg p-4">
                                    <h3 className="text-purple-300 font-semibold mb-2 flex items-center">
                                        <Sparkles className="w-4 h-4 mr-2" />
                                        Daily Summary
                                    </h3>
                                    <div className="text-gray-300 text-sm">
                                        <Markdown content={summaries[formatDate(selectedDate)]} />
                                    </div>
                                </div>
                            )}

                            <div className="space-y-1">
                                {dateEntries.map((entry, idx) => (
                                    <div key={idx} className="border-l-4 border-blue-500 pl-2 py-1 bg-gray-900/50 rounded hover:bg-gray-900 transition-colors">
                                        <div className="flex items-start">
                                            <span className="font-mono text-xs text-gray-500 mr-2 mt-0.5">
                                                [{formatTime(entry.timestamp)}]
                                            </span>
                                            {entry.tag && (
                                                <span className="text-xs font-semibold text-blue-400 mr-2 mt-0.5">
                                                    ({entry.tag})
                                                </span>
                                            )}
                                            <span className="text-sm text-gray-300 flex-1">
                                                {entry.note}
                                            </span>
                                        </div>
                                    </div>
                                ))}
                            </div>

                            <button
                                onClick={() => {
                                    setSelectedDate(null);
                                    setView('all'); // Explicit explicit
                                }}
                                className="mt-4 w-full bg-gray-700 text-white py-2 px-4 rounded-lg hover:bg-gray-600 text-sm"
                            >
                                Back to All Entries
                            </button>
                        </div>
                    </div>
                );
            }

            // Overview view (date selection)
            if (view === 'overview') {
                return (
                    <div className="max-w-4xl mx-auto p-2 bg-gray-900 min-h-screen">
                        <div className="bg-gray-800 rounded-lg shadow-lg p-3 border border-gray-700">
                            <h2 className="text-xl font-bold mb-4 text-gray-100 flex items-center border-b border-gray-700 pb-2">
                                <Calendar className="w-6 h-6 mr-2" />
                                Select a Date to Review
                            </h2>

                            {dates.length === 0 ? (
                                <p className="text-gray-500 text-center py-6">No entries found.</p>
                            ) : (
                                <div className="space-y-4">
                                    {Object.keys(groupedDates).sort((a, b) => b - a).map(year => (
                                        <div key={year}>
                                            <div className="sticky top-0 bg-gray-800 py-1 z-10">
                                                <h3 className="text-lg font-bold text-blue-400">{year}</h3>
                                            </div>
                                            {Object.keys(groupedDates[year]).map(month => {
                                                const monthDates = groupedDates[year][month];
                                                return (
                                                    <div key={month} className="mb-3 ml-2">
                                                        <h4 className="text-sm font-semibold text-gray-500 uppercase tracking-wider mb-2">{month}</h4>
                                                        <div className="grid grid-cols-1 gap-2">
                                                            {monthDates.map((date) => {
                                                                const globalIndex = dates.indexOf(date);
                                                                const count = getEntriesForDate(date).length;
                                                                return (
                                                                    <button
                                                                        key={date}
                                                                        onClick={() => handleDateSelect(date)}
                                                                        className="group flex items-center justify-between p-2 bg-gray-900 hover:bg-gray-700 rounded border border-gray-700 hover:border-blue-500 transition-all text-left"
                                                                    >
                                                                        <div className="flex items-center">
                                                                            <span className="font-mono text-sm text-gray-600 group-hover:text-blue-400 w-8">
                                                                                {(globalIndex + 1).toString().padStart(2, '0')}
                                                                            </span>
                                                                            <span className="text-gray-200 text-sm font-medium">
                                                                                {formatDate(date)}
                                                                            </span>
                                                                        </div>
                                                                        <span className="text-xs bg-gray-800 px-2 py-0.5 rounded text-gray-400 group-hover:text-white">
                                                                            {count}
                                                                        </span>
                                                                    </button>
                                                                );
                                                            })}
                                                        </div>
                                                    </div>
                                                );
                                            })}
                                        </div>
                                    ))}
                                </div>
                            )}

                            <button
                                onClick={() => setView('all')}
                                className="mt-4 w-full bg-gray-700 text-white py-2 px-4 rounded-lg hover:bg-gray-600 text-sm"
                            >
                                View All Entries
                            </button>
                        </div>
                    </div>
                );
            }

            // Tracker/All Entries View (fallback when no specific view)
            // Tracker/All Entries View
            return (
                <div className="max-w-4xl mx-auto p-2 bg-gray-900 min-h-screen">
                    <div className="bg-gray-800 rounded-lg shadow-lg p-3 border border-gray-700">
                        <div className="flex items-center justify-between mb-2 border-b border-gray-700 pb-2">
                            <h1 className="text-xl font-bold text-gray-100 flex items-center">
                                <Clock className="w-6 h-6 mr-2" />
                                All Entries
                            </h1>
                            <button
                                onClick={() => setView('overview')}
                                className="bg-blue-600 text-white py-1 px-3 rounded hover:bg-blue-700 font-medium flex items-center text-xs"
                            >
                                <Calendar className="w-3 h-3 mr-1" />
                                Review by Date
                            </button>
                        </div>

                        {entries.length === 0 ? (
                            <p className="text-gray-500 text-center py-6">No entries found.</p>
                        ) : (
                            <div className="space-y-4">
                                {dates.map(date => {
                                    const dateEntries = getEntriesForDate(date);
                                    const dateObj = new Date(date);
                                    const dateHeader = dateObj.toLocaleDateString('en-US', {
                                        weekday: 'short',
                                        year: 'numeric',
                                        month: 'short',
                                        day: 'numeric'
                                    });

                                    return (
                                        <div key={date}>
                                            <h3 className="text-sm font-bold text-blue-400 bg-gray-900/50 px-2 py-1 rounded mb-1 border-l-2 border-blue-500">
                                                {dateHeader}
                                            </h3>
                                            <div className="space-y-0.5 pl-2">
                                                {dateEntries.map((entry, idx) => (
                                                    <div key={idx} className="font-mono text-xs text-gray-300 p-1 hover:bg-gray-900 rounded flex items-start">
                                                        <span className="text-gray-500 mr-2 whitespace-nowrap">
                                                            [{formatTime(entry.timestamp)}]
                                                        </span>
                                                        {entry.tag && <span className="text-blue-400 font-semibold mr-2 whitespace-nowrap">({entry.tag})</span>}
                                                        <span className="text-gray-300">{entry.note}</span>
                                                    </div>
                                                ))}
                                            </div>
                                        </div>
                                    );
                                })}
                            </div>
                        )}
                        <p className="text-xs text-gray-600 mt-4 text-center border-t border-gray-800 pt-2">
                            Data is processed locally. Entries are sent to Google Gemini only when you click "Generate AI Summary".
                        </p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<TimeTracker />);
    </script>
</body>

</html>